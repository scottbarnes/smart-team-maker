import sys, os, argparse, logging
from send_mail import send_mail
from dataclasses import dataclass
from typing import List
from openpyxl import load_workbook, Workbook
import click
from openpyxl.utils.exceptions import InvalidFileException
from jinja2.exceptions import TemplateNotFound


##  Spreadsheet column mapping (zero-indexed)
# Participants
CONTACT_NUMBER = 11
DEGREE = 4
DEPARTMENT = 10
EMAIL = 1
FIELD = 24
FIRST_NAME = 2 
LAST_NAME= 9
NATIONALITY = 22
UNIVERSITY_COLUMNS = range(13, 22)  # all possible columns with the university name.
UNIVERSITY_COUNTRY = 12

## Some default values
work_dir = '.'
input_filename = "smart.xlsx"
input_workbook = load_workbook(filename=input_filename)  # read_only=True breaks iter_rows
input_sheet = input_workbook.active
output_filename = 'smart_mail_merge.xlsx'
output_workbook = Workbook()
output_sheet = output_workbook.active
fake_output_filename = 'fake_smart_teams.xlsx'
fake_output_workbook = Workbook()
fake_output_sheet = fake_output_workbook.active
spreadsheet_titles = [
    "ID",
    "Team ID",
    "First name",
    "Last name",
    "Email",
    "Contact number",
    "University",
    "University country",
    "Department",
    "Degree",
    "Field",
    "Nationality",
]
## old titles
# spreadsheet_titles = [
#             "Team ID",
#             "First Name 1",
#             "Last Name 1",
#             "Email 1",
#             "First Name 2",
#             "Last Name 2",
#             "Email 2",
#             "First Name 3",
#             "Last Name 3",
#             "Email 3",
#             "First Name 4",
#             "Last Name 4",
#             "Email 4",
#             "First Name 5",
#             "Last Name 5",
#             "Email 5",
#         ]

@dataclass
class Team:
    id: int
    members: list

    def fields(self):
        result = []
        for member in self.members:
            result.append(member.field)
        return result

    def nationalities(self):
        result = []
        for member in self.members:
            result.append(member.nationality)
        return result

    def member_count(self):
        return len(self.members)

@dataclass
class TeamScore:
    id: int
    plan_completeness: int
    development_potential: int
    pitch_execution: int
    expected_benefits: int

    # Return the total score, scaled to be out of 100.
    def score(self):
        result = (20 * (self.plan_completeness / 5)) \
                + (30 * (self.development_potential / 5)) \
                + (20 * (self.pitch_execution / 5)) \
                + (30 * (self.expected_benefits / 5))
        return result

@dataclass
class Participant:
    id: int
    team_id: int
    field: str
    nationality: str
    university: str
    university_country: str
    first_name: str
    last_name: str
    email: str
    contact_number: str
    department: str
    degree: str

def team_creator(spreadsheet, team_size) -> List:
    """ Take a spreadsheet and a number of members per team and return a list of 
    teams with the number of members defined by team_size. """
    total_participants = get_real_max_rows(spreadsheet) + team_size  # Add another team to hold the remainder
    total_teams = total_participants // team_size  # number of teams
    result = []
    # Loop total_teams to create the team objects.
    i = 1  # start at 1
    while i < (total_teams + 1):
        result.append(Team(id=i, members=[]))
        i += 1
    return result

def fake_team_creator(participant_num, team_size) -> List:
    """ Take a number of fake participants and a team size and return a list of teams. """
    total_participants = participant_num + team_size  # Add another team to hold the remainder
    total_teams = total_participants // team_size  # number of teams
    result = []
    # Loop total_teams to create the team objects.
    i = 1  # start at 1
    while i < (total_teams + 1):
        result.append(Team(id=i, members=[]))
        i += 1
    return result
    
# Create a list of participants
def get_participants(spreadsheet) -> List:
    """ Take an openpyxl sheet and return a list of participants, one per row. """

    # Detect the type of spreadsheet this is (e.g. Google Form sign-up, teams sheet, etc.)
    spreadsheet_type = '' 
    if spreadsheet['B1'].value == 'Team ID':
        spreadsheet_type = 'team_form'
    elif spreadsheet['B1'].value == 'Email Address':
        spreadsheet_type = 'original_google_form'
    else:
        raise ValueError("Couldn't detect the spreadsheet type.\nThe script checks cell B1 for 'Team ID' as generated by this script, or 'Email Address' as generated by the Google Form.")
    result = []
    if spreadsheet_type == 'original_google_form':
        for index, row in enumerate(spreadsheet.iter_rows(min_row=1, values_only=True)):
            #  Skip the title/header column.
            if row[FIRST_NAME] == 'First name':
                continue

            # Filter out the empty rows Google Docs adds to the end.
            if row[0] == None:
                continue

            result.append(
                Participant(id=index,
                            field=row[FIELD],
                            nationality=nationality_normalizer(row[NATIONALITY]),
                            university=university_finder(row, UNIVERSITY_COLUMNS),
                            university_country=row[UNIVERSITY_COUNTRY],
                            first_name=row[FIRST_NAME],
                            last_name=row[LAST_NAME],
                            email=row[EMAIL],
                            contact_number=row[CONTACT_NUMBER],
                            department=row[DEPARTMENT],
                            degree=row[DEGREE],
                            team_id=0,
                           )
            )
        return result
    elif spreadsheet_type == 'team_form':
        for index, row in enumerate(spreadsheet.iter_rows(min_row=1, values_only=True)):
            #  Skip the title/header column.
            if row[1] == 'Team ID':
                continue

            result.append(
                Participant(id=row[0],
                            team_id=row[1],
                            first_name=row[2],
                            last_name=row[3],
                            email=row[4],
                            contact_number=row[5],
                            university=row[6],
                            university_country=row[7],
                            department=row[8],
                            degree=row[9],
                            field=row[10],
                            nationality=row[11],
                           )
            )
        return result
    else:
        raise ValueError('Spreadsheet does not appear to be from the Google Form or created by this script.')

def nationality_normalizer(nationality: str) -> str:
    """ Take a nationality string and return a normalized nationality.
        E.g. Taiwan -> Taiwanese, R.O.C. -> Taiwanese """

    nationality = str(nationality).lower()
    if 'bangl'.lower() in nationality:
        return 'Bangladeshi'
    elif 'india'.lower() in nationality:
        return 'Indian'
    elif 'indo'.lower() in nationality:
        return 'Indonesian'
    elif 'mala'.lower() in nationality:
        return 'Malaysian'
    elif 'pak'.lower() in nationality:
        return 'Pakistani'
    elif 'roc'.lower() in nationality or 'r.o.c.'.lower() in nationality or 'taiw'.lower() in nationality or 'republic of ch'.lower() in nationality:
        return 'Taiwanese'
    # China must come after because first match wins, and 'china' would match 'Republic of China'
    elif 'china'.lower() in nationality or 'chinese'.lower() in nationality:
        return 'Chinese'
    elif 'sing'.lower() in nationality:
        return 'Singaporean'
    elif 'viet'.lower() in nationality:
        return 'Vietnamese'
    elif 'usa'.lower() in nationality or 'america'.lower() in nationality:
        return 'USA'
    else:
        return f'OTHER: {nationality}' 

def university_finder(participant_row, university_columns):
    """ Take a participant and get their university from one of the 9 columns it might be in.
        Should return a string. """
    # Go through each possible university row and find the university, then return it.
    for cell in university_columns:
        if participant_row[cell]:
            return participant_row[cell]

# Put the Participants on to teams
def inject_participant(team, participant, team_size, rnd) -> bool:
    """ For a given team and participant, return True if a participant should be injected. """

    # Don't add more than team_size members. 
    if team.member_count() >= team_size:
        return False

    # Allow two Indians in first, owing to their enthusiasm.
    if rnd <= 5:
        # Fill teams with two Indian participants, owing to their enthusiasm.
        if participant.nationality == 'Indian' and (team.nationalities().count('Indian') <= 1):
            print(f'Adding Indian {participant.first_name}')
            return True
    # Try to spread only unique nationalities and fields of study
    elif rnd >= 6 and rnd <= 9:
        if participant.field in team.fields():
            return False
        elif participant.nationality in team.nationalities():
            return False
        else:
            return True
    # Allow duplicate fields of study but not yet nationality.
    elif rnd == 10:
        if participant.nationality in team.nationalities():
            return False
        elif participant.field in team.fields():
            return True
    # Now allow triplicate engineers.
    elif rnd >= 11 and rnd <= 15:
        if participant.field == 'Engineering' and (team.fields().count('Engineering') <= 3):
            return True
        else:
            return False
    # Now allow triplicates
    elif rnd >= 16 and rnd <= 20:
        if team.fields().count(participant.field) <= 3:
            return True
        elif team.nationalities().count(participant.nationality) <= 3:
            return True
        else:
            return False
    # Just add the first person we encounter
    elif rnd >= 21:
        return True

    return False  # Just to squelch type checking in the function definition.

    
def get_real_max_rows(spreadsheet):
    """ Take a spreadsheet, count until encountering a null row, and return that number.
    Spreadsheets from Google Docs seem to add +100 rows. Filter those out. """
    count = 0
    for row in spreadsheet.iter_rows(values_only=True):
        if row[0] != None:
            count += 1
    return count

def pretty_print_teams(teams):
    """ Take a list of teams and pretty-print them. """
    for team in teams:
        print(f'\nTeam ID: {team.id}')
        print(f'Member count: {team.member_count()}')
        for member in team.members:
            print(f'- {member.first_name} {member.last_name}\tNationality: {member.nationality}\tField: {member.field}\tUniversity: {member.university}')

def print_rows(sheet):
    """ Take sheet (workbook.active) and print out spreadsheet rows. """
    for row in sheet.iter_rows(values_only=True):
        print(row)

def create_mailmerge(teams: List, output_workbook, output_sheet, output_filename, titles):
    """ Take a list of team objects, an output spreadsheet, and the spreadsheet title column 
    and append the data to the output spreadsheet. """
    output_sheet.append(titles)
    for team in teams:
        for member in team.members:
            data = []
            data.append(member.id)
            data.append(team.id)
            data.append(member.first_name)
            data.append(member.last_name)
            data.append(member.email)
            data.append(member.contact_number)
            data.append(member.university)
            data.append(member.university_country)
            data.append(member.department)
            data.append(member.degree)
            data.append(member.field)
            data.append(member.nationality)
            output_sheet.append(data)

    output_workbook.save(output_filename)


## old format 
# def create_mailmerge(teams: List, output_workbook, output_sheet, output_filename, titles):
#     """ Take a list of team objects, an output spreadsheet, and the spreadsheet title column 
#     and append the data to the output spreadsheet. """
#     output_sheet.append(titles)
#     for team in teams:
#         data = [team.id]
#         for member in team.members:
#             data.append(member.first_name)
#             data.append(member.last_name)
#             data.append(member.email)
#         output_sheet.append(data)

#     output_workbook.save(output_filename)

# Create a list of teams
# def get_teams(spreadsheet) -> List:
#     """ Take an openpyxl sheet and return a list of teams, one per row. """
#     result = []
#     for index, row in enumerate(spreadsheet.iter_rows(min_row=1,
#                                                 values_only=True)):
#         # Filter out the empty rows Google Docs creates.
#         if row[0] == None:
#             continue

#         result.append(
#             Participant(id=index,
#                         field=row[FIELD],
#                         nationality=nationality_normalizer(row[NATIONALITY]),
#                         university=university_finder(row, UNIVERSITY_COLUMNS),
#                         university_country=row[UNIVERSITY_COUNTRY],
#                         first_name=row[FIRST_NAME],
#                         last_name=row[LAST_NAME],
#                         email=row[EMAIL],
#                         contact_number=row[CONTACT_NUMBER],
#                         department=row[DEPARTMENT],
#                         degree=row[DEGREE],
#                         team_id=0,
#                        )
#         )
#     return result


# Click group setup
@click.group()
def cli():
    pass

@cli.command()
@click.option(
    '--server',
    envvar='EMAIL_SERVER',
    required=True,
    help='Email server. Also reads from EMAIL_SERVER environment variable.'
)
@click.option(
    '--port',
    envvar='EMAIL_PORT',
    default=465,
    help='Email server port. Also reads from EMAIL_PORT environment variable.'
)
@click.option(
    '--sender',
    envvar='EMAIL_SENDER',
    required=True,
    help='Email account name. Also reads from EMAIL_SENDER environment variable.'
)
@click.option(
    '--password',
    envvar="EMAIL_PASSWORD",
    required=True,
    help='Email account password. Also reads from EMAIL_PASSWORD environment variable.'
)
@click.option(
    '--spreadsheet',
    required=True,
    help='Path to the spreadsheet (generated by this script) containing the teams.'
)
@click.option(
    '--subject',
    required=True,
    help='Email subject',
)
@click.option(
    '--template',
    required=True,
    help='Filename (not path) of Jinja2 template, as located in email_templates, associated with this email.',
)

def email_all_teams(server, port, sender, password, spreadsheet, subject, template):
    """ Send out email to all teams. """
    # Read in the spreadsheet data, as supplied on the command line.
    try:
        workbook = load_workbook(filename=spreadsheet)  # read_only=True breaks iter_rows
    except InvalidFileException as e:
        sys.exit(e)
    except FileNotFoundError as e:
        sys.exit(e)
    sheet = workbook.active
    participants = get_participants(sheet)
    # for participant in participants:
    #     print(participant)

    # This is why databases exist. :(
    number_of_teams = find_highest_team_number(participants)
    # print(number_of_teams)
    teams = team_creator(sheet, number_of_teams)
    add_participant_to_their_team(participants, teams)
    # print(teams)

    # Email each team
    for team in teams:
        recipients = []
        for member in team.members:
            recipients.append(member.email)
        # print(f'Team {team.id}\'s recipients: {recipients}')
        send_mail(server, port, recipients, sender, password, subject, template, body=None, team=team)
    
def find_highest_team_number(participants: List) -> int:
    """ Take a spreadsheet and find the highest team number (to get total number of teams) """
    result = 0
    for participant in participants:
        if participant.team_id > result:
            result = participant.team_id
    return result

def add_participant_to_their_team(participants: List, teams: List):
    """ Go through the rows of participants and add them to their teams. """
    for participant in participants:
        # print(f'Adding {participant.first_name} with Team ID {participant.team_id} to Team {teams[participant.team_id - 1]}\n')
        teams[participant.team_id - 1].members.append(participant)  # -1 b/c zero index.
    print(teams)

def participant_de_dupe(participants) -> List:
    """ Take a list of participants and return a deduped list (based on email). """
    checked_emails = []
    deduped = []
    for participant in participants:
        email = participant.email
        if email not in checked_emails:
            checked_emails.append(email)
            deduped.append(participant)

    return deduped

@cli.command()
def make_fake_teams():
    """ Make fake teams. """
    fake_participants = 4
    fake_team_size = 2
    fake_first_name = 'Scott'
    fake_last_name = 'Barnes'
    username = 'scottreidbarnes'
    domain = 'gmail.com'
    teams = fake_team_creator(fake_participants, fake_team_size)

    for team in teams:
        for n in range(1, fake_team_size + 1):
            id = teams.index(team) + n
            p = Participant(id=id,
                            field='Napping',
                            nationality='Citizen of the World',
                            university='Some school',
                            university_country='USA',
                            first_name=f'{fake_first_name}_T{teams.index(team)+1}_P{n}',
                            last_name=f'{fake_last_name}_T{teams.index(team)+1}_P{n}',
                            email=username+f'+T-{teams.index(team)+1}_P-{n}@{domain}',
                            contact_number='55555555',
                            department='Philosophy',
                            degree='Bachelor',
                            team_id=team.id,
                           )

            team.members.append(p)

    pretty_print_teams(teams)

    # Write the output to an .xlsx file.
    create_mailmerge(
        teams,
        fake_output_workbook,
        fake_output_sheet,
        fake_output_filename,
        spreadsheet_titles
    )
    print_rows(output_sheet)
    print(f'\nOutput written to ./{fake_output_filename}')

@cli.command()
# @click.option(
#     '--output_filename',
#     help='Output filename (smart_teams.xlsx, by default)'
# )
def make_teams():
    """
    Create teams and write them to an Excel file.
    """
    team_size = 5

    # Set everything up.
    participants = get_participants(input_sheet)
    # dedupe participants list
    participants = participant_de_dupe(participants)
    teams = team_creator(input_sheet, team_size)
    full_teams = []
    popped = 0
    participants_popped = 0

    # Use different 'rounds' to fill the teams, taking each team in successing, and running
    # inject_participant() on it. Do this until we run out of teams (or participants).
    #
    # One thing to look out for here is that pooping the teams changes the list index,
    # So depending on how the loop is used, that could potentially break things. E.g.,
    # that is why the remaining teams, once participants run out, are appended to full_teams
    # and not .pop()ed from teams: if there were 4 teams left that weren't full, the for
    # loop would pop the first two, the last two would move two index places towards zero,
    # and the for loop would hit an empty index on teams 3 and 4.

    rnd = 0
    while True:
        # Take each team in turn, and then go through all participants trying to add one
        # until a participant is added, stop, and go to the next team. Repeat until no
        # more participants to place.
        for team in teams:
            for participant in participants:
                if inject_participant(team, participant, team_size, rnd):
                    print(f'Adding {participant} to {team.id}')
                    team.members.append(participant)
                    participants.pop(participants.index(participant))
                    participants_popped += 1
                    print(f'participants remaining: {len(participants)}')
                    print(f'participants popped: {participants_popped}')

                    # Get out if successfully adding a participant and don't add more.
                    break

            if team.member_count() >= team_size:
                # print(f'Appending full team: {team}')
                full_teams.append(team)
                print(f'Popping team: {team.id}')
                teams.pop(teams.index(team))
                popped += 1
                print(f'Teams popped: {popped}')
                print(f'Teams remaining: {len(teams)}')

        if len(participants) == 0 or len(teams) == 0:
            print(f'Popping remaining teams')
            for team in teams:
                print(f'Popping team {team.id} with {team.member_count()} participants')
                print(f'{team.members}')
                print('\n')
                full_teams.append(team)
                # teams.pop(teams.index(team))
                print(f'Remaining teams: {teams}')

            print(f'Stopping with {len(participants)} participants and {len(teams)} teams left.')
            for team in teams:
                print(f'Popping team {team.id} with {team.member_count()} participants')
                print(f'{team.members}')
                print('\n')

            break  # Break out of the while loop.

        print(f'new round: {rnd}')
        rnd += 1

    # See the output on the console.
    pretty_print_teams(full_teams)

    # Write the output to a .xlsx file.
    create_mailmerge(
        full_teams,
        output_workbook,
        output_sheet,
        output_filename,
        spreadsheet_titles
    )
    # print_rows(output_sheet)

    print(f'\nTeams written to ./{output_filename}')


def update_score(dictionary, team_number, criterion, points):
    """ Make sure a team exists; if not, create it, and either way, update its points. """
    team = dictionary.get(team_number)  # None if non-existent.
    if not team:
        print(f'Creating Team {team_number}')
        dictionary[team_number] = TeamScore(
            id=team_number,
            plan_completeness=0,
            development_potential=0,
            pitch_execution=0,
            expected_benefits=0,
        )

    print(f'Updating Team {team_number} to have {points} points for {criterion}')
    team = dictionary.get(team_number)
    if criterion == 'plan_completeness':
        team.plan_completeness = points
    elif criterion == 'development_potential':
        team.development_potential = points
    elif criterion == 'pitch_execution':
        team.pitch_execution = points
    elif criterion == 'expected_benefits':
        team.expected_benefits = points
    else:
        raise ValueError('Unknown judging criteria')

@cli.command()
@click.option(
    '--file',
    required=True,
    help='Path to the scores spreadsheet greated by Google Forms'
)
def get_team_scores(file):
    """ Tally the scores from the Google Form .xlsx sheet and print them out. """
    try:
        workbook = load_workbook(filename=file)
    except InvalidFileException as e:
        sys.exit(e)
    except FileNotFoundError as e:
        sys.exit(e)
    sheet = workbook.active
    scores = {}  # Set up the main dictionary
    for row in sheet.iter_rows(values_only=True):
        # Filter out the header row.
        if type(row[1]) == str:
            continue

        # There has to be a better way.
        for index, cell in enumerate(row):
            # Plan completeness
            if index == 1:
                team_number = int(cell)
                criterion = 'plan_completeness'
                update_score(scores, team_number, criterion, 5)
            elif index == 2:
                team_number = int(cell)
                criterion = 'plan_completeness'
                update_score(scores, team_number, criterion, 4)
            elif index == 3:
                team_number = int(cell)
                criterion = 'plan_completeness'
                update_score(scores, team_number, criterion, 3)
            elif index == 4:
                team_number = int(cell)
                criterion = 'plan_completeness'
                update_score(scores, team_number, criterion, 2)
            elif index == 5:
                team_number = int(cell)
                criterion = 'plan_completeness'
                update_score(scores, team_number, criterion, 1)
            # Development potential
            if index == 6:
                team_number = int(cell)
                criterion = 'development_potential'
                update_score(scores, team_number, criterion, 5)
            elif index == 7:
                team_number = int(cell)
                criterion = 'development_potential'
                update_score(scores, team_number, criterion, 4)
            elif index == 8:
                team_number = int(cell)
                criterion = 'development_potential'
                update_score(scores, team_number, criterion, 3)
            elif index == 9:
                team_number = int(cell)
                criterion = 'development_potential'
                update_score(scores, team_number, criterion, 2)
            elif index == 10:
                team_number = int(cell)
                criterion = 'development_potential'
                update_score(scores, team_number, criterion, 1)
            # Pitch execution
            if index == 11:
                team_number = int(cell)
                criterion = 'pitch_execution'
                update_score(scores, team_number, criterion, 5)
            elif index == 12:
                team_number = int(cell)
                criterion = 'pitch_execution'
                update_score(scores, team_number, criterion, 4)
            elif index == 13:
                team_number = int(cell)
                criterion = 'pitch_execution'
                update_score(scores, team_number, criterion, 3)
            elif index == 14:
                team_number = int(cell)
                criterion = 'pitch_execution'
                update_score(scores, team_number, criterion, 2)
            elif index == 15:
                team_number = int(cell)
                criterion = 'pitch_execution'
                update_score(scores, team_number, criterion, 1)
            # Expected benefits
            if index == 16:
                team_number = int(cell)
                criterion = 'expected_benefits'
                update_score(scores, team_number, criterion, 5)
            elif index == 17:
                team_number = int(cell)
                criterion = 'expected_benefits'
                update_score(scores, team_number, criterion, 4)
            elif index == 18:
                team_number = int(cell)
                criterion = 'expected_benefits'
                update_score(scores, team_number, criterion, 3)
            elif index == 19:
                team_number = int(cell)
                criterion = 'expected_benefits'
                update_score(scores, team_number, criterion, 2)
            elif index == 20:
                team_number = int(cell)
                criterion = 'expected_benefits'
                update_score(scores, team_number, criterion, 1)

        # 'scores' is a dictionary with key, value as team_id and team_object.
        # Get an iterable of all of those objects so we can work on them more easily.
        teams = scores.values()
        # Create a score dictionary with k, v team_id and score.
        score_d = {}
        for team in teams:
            print(f'Team {team.id} scored {team.score()}')
            score_d[team.id] = team.score()

        # Sort the scores dictionary, lowest to highest.
        results = {k: v for k, v in sorted(score_d.items(), key=lambda item: item[1])}
        print(f'Results: {results}')
        for k in results:
            print(f'Team {k} scored {results.get(k)} out of 100.')


if __name__ == '__main__':
    cli()
    # script = Teams()
    # script.go()
